// Generated by IcedCoffeeScript 1.3.1b
(function() {
  var affine, polygon;

  affine = require('./affine');

  polygon = (function() {

    polygon.name = 'polygon';

    function polygon(vertices) {
      if (vertices != null) {
        this.vertices = vertices;
      } else {
        this.vertices = [];
      }
    }

    polygon.prototype.copy = function() {
      var new_v, v, _i, _len, _ref;
      new_v = [];
      _ref = this.vertices;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        new_v.push(v.copy());
      }
      return new polygon(new_v);
    };

    polygon.prototype.addVertex = function(v) {
      return this.vertices.push(v);
    };

    polygon.prototype.transform = function(aff) {
      var v, _i, _len, _ref, _results;
      _ref = this.vertices;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _results.push(aff.transformVec(v));
      }
      return _results;
    };

    polygon.prototype.getXMin = function() {
      var best, i, v, _i, _len, _ref;
      best = 0;
      _ref = this.vertices;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        v = _ref[i];
        if ((i === 0) || v.v0 < best) best = v.v0;
      }
      return best;
    };

    polygon.prototype.getXMax = function() {
      var best, i, v, _i, _len, _ref;
      best = 0;
      _ref = this.vertices;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        v = _ref[i];
        if ((i === 0) || v.v0 > best) best = v.v0;
      }
      return best;
    };

    polygon.prototype.getYMin = function() {
      var best, i, v, _i, _len, _ref;
      best = 0;
      _ref = this.vertices;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        v = _ref[i];
        if ((i === 0) || v.v1 < best) best = v.v1;
      }
      return best;
    };

    polygon.prototype.getYMax = function() {
      var best, i, v, _i, _len, _ref;
      best = 0;
      _ref = this.vertices;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        v = _ref[i];
        if ((i === 0) || v.v1 > best) best = v.v1;
      }
      return best;
    };

    return polygon;

  })();

  exports.polygon = polygon;

  exports.factory = {
    unitSquare: function() {
      return new polygon([[0.5, 0.5], [-0.5, 0.5], [-0.5, -0.5], [0.5, -0.5]]);
    },
    unitCircleApprox: function(num) {
      var i, p, radian_increment, radians, _i;
      radian_increment = 2.0 * Math.PI / num;
      radians = 0;
      p = new polygon();
      for (i = _i = 0; 0 <= num ? _i < num : _i > num; i = 0 <= num ? ++_i : --_i) {
        radians += radian_increment;
        p.addVertex([0.5 * Math.cos(radians), 0.5 * Math.sin(radians)]);
      }
      return p;
    }
  };

}).call(this);
